# 코드 입력과 처리 {#sec-code-exe}

콰르토는 R, 파이썬, 자바스크립트(ObservableJS) 언어 등에 대한 컴퓨테이션 엔진을 사용하여 코드를 실행하고 그 결과를 문서에 포함시키고 이것을 프로세싱하여 결과물을 만든다. 이 장에서는 콰르토 문서와 컴퓨테이션 엔진을 바인딩하는 방법, 콰르토가 그런 엔진을 실행시키는 방식과 개별 코드 블록을 실행하고, 결과를 원하는 방식으로 조절하기 위한 방법 등을 다룬다.

콰르토는 컴퓨테이션 엔진을 통해서 다양한 프로그래밍 언어와 연결된다. 따라서 콰르토 문서와 컴퓨테이션 엔진을 잘 연결하는 것이 효과적인 사용을 위해서 꼭 필요하다. 콰르토에서는 **소스 파일의 종류에 따라서** 다음과 같은 방식으로 엔진이 선택된다.

-   `.qmd` 문서: YAML 헤더 등에서 별도로 엔진을 선택하지 않으면, 문서 안의 실행 코드를 확인하여 **R 실행 코드가 있으면 니터(Knitr) 엔진을 선택하고 파이썬 실행 코드가 있으면 주피터(Jupyter) 엔진이 선택**된다. **첫 번째 실행 코드**를 보고 엔진을 선택하는 것이다. 그러나 이런 디폴트 행동에 의존하는 것보다 YAML 헤더에서 `knitr: true` 또는 `jupyter:` 필드를 사용하여 엔진을 명확히 지정하여 사용하는 것을 권한다.

-   `.ipynb`: `.ipybnb` 파일로 작업하면 주피터 엔진이 선택된다.

YAML 헤더에서 엔진을 선택하는 방법은 다음과 같다. R 니터 엔진인 경우는 다음과 같이 지정한다.

```{verbatim}
---
knitr: true
---
```

파이썬은 `jupyter`라는 필드를 사용한다.

```{verbatim}
---
jupyter: python3
---
```

## 코드 블록과 코드 셀 

콰르토는 RStudio 통합개발환경이나 주피터 노트북을 사용하지 않는 VS Code에서도 사용할 수 있고, 전통적인 주피터 노트북/주피터랩에서도 사용 가능하다. 주피터 노트북에서는 코드를 코드 셀(Code Cells)에 입력한다. 나머지 에디터에서는 **코드 블록**이라고 부르는 곳에 코드를 입력한다. 이하에서 코드 블록이라고 하는 것은 이 의미를 가진다. 코드 셀은 주피터 노트북 환경에서 코드를 입력하는 셀을 말한다. 이름에 차이는 있지만 코드 옵션 등을 적용하는 방법은 차이가 없다.

## 코드 블록 생성과 코드 블록 옵션 지정하기 {#sec-create-code-block}

콰르토 문서에서 엔진과 연결된 코드는 코드 블록에 넣는다. 코드는 실제로 실행시키기 위한 것도 있지만 때로는 실행하지 않고 그 자체를 문서의 내용으로 넣는 경우도 있다.

계산이 되는 코드 블록은 다음과 같이 만든다(계산이 되지 않고 그냥 설명 등을 위해서 코드 블록을 만들 수 있다). 보통은 편집창 위에 있는 "C"와 플러스 기호로 되어 있는 아이콘을 가진 버튼을 클릭하거나 단축키를 사용하여 입력한다. 텍스트로 직접 입력해도 되는데, 백틱 3개로 시작하고, 끝날 때도 백틱 3개로 끝난다는 것을 주의한다. 

![코드 블록 넣기](images/insert_code.png){#fig-insert-code}


-   윈도우: Ctrl + Alt + I
-   맥오에스: Command + Option + I

R 코드 블록은 다음과 같이 작성한다.

```{r}
#| echo: fenced
#| label: fig-histo
#| eval: false
hist(rnorm(1000))
```

파이썬 코드 블록은 `r` 대신 `python`을 쓴다.

```{python}
#| echo: fenced
#| label: pkg-import
#| eval: false

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
```

코드 블록 안에서 `#|`을 시작되는 부분이 **코드 블록 옵션**이다. 

## 코드 실행 워킹 디렉터리

콰르토 문서의 코드가 실행되는 워킹 디렉터리는 **현재 콰르토 문서를 포함하고 있는 디렉터리**이다. 그래서 이미지를 포함시키기 위해서 그 경로를 표히하는 경우, 현재 콰르토 문서를 포함하는 디렉터리를 기준으로 경로를 지정해야 한다. 다음과 같이 폴더가 구성되었다고 생각해 보자.

```{verbatim}
.
├── hello.qmd
└── images
    └── my_image.png

```

현재 디렉터리에 `hello.qmd`가 있고, 사용할 이미지는 `images` 서브 디렉터리에 `my_images.png`로 있을 경우, `hello.qmd`에서는 다음과 같이 경로를 사용하여 이미지를 읽는다. 

```{verbatim}
![그림에 대한 캡션](images/my_image.png)
```

한, 두 개의 문서를 만들고 프로세싱하는 것은 이와 같이 간단하다. 하지만 여러 파일들을 사용하여 복합적인 작업인 경우, 코드 실행 기준을 현재 파일의 위치가 아닌 프로젝트 루트 디렉터리로 잡아야 할 필요가 생긴다. 이 부분은 프로젝트를 다루는 장에서 다시 설명한다.


## 코드 실행 순서와 세션

당연한 이야기일 수 있겠지만, 콰르토 문서에 코드 블록들은 **위에서 아래로 순차적으로 실행되고, 하나의 문서 안의 코드 블록들은 하나의 세션에서 실행된다**. 그래서 위에서 변수에 할당된 값들은 아래 코드 블록에서 해당 변수의 이름을 통해서 그 값에 접근할 수 있다.

코드 블록을 하나씩 실행하여 몇 개를 실행하고 나서 앞으로 가서 다시 해당 코드 블록을 실행해도 문제 없이 실행된다. 때로는 이것이 혼란을 불러 오기 때문에 원하는 결과가 제대로 나오는지 확인하려면 결과들을 다시 지우고 새롭게 세션을 시작할 필요가 있다. RStudio에는 [@fig-restart-r]와 같이 편집창 위에 **Run** 버튼이 있고, 오른쪽에 아래 화살표를 클릭하면 드롭다운 메뉴가 열린다. 여기서 R 세션을 새로 시작하거나, 새로 시작하고 다시 코드들을 실행하거나 등을 명령할 수 있다. 주피터랩에서는 같은 맥락으로 커널을 다시 시작하면 된다.


![R 세션을 다시 시작하기](images/restart_r.png){#fig-restart-r}


최근 이런 선형적인 실행 순서에 대한 비판도 일어나고 있다. 콰르토가 지원하는 옵저버블 노트북(Observable Notebook)은 <https://observablehq.com>에서 웹을 통해 지원되는 노트북이다. 콰르토는 옵저버를 노트북의 핵심 라이브러리를 가지고 와서 사용하는 것으로, 웹에서 지원하는 노트북에서는 코드들이 선형적으로 실행되지 않는다. 엑셀 스프레드시트를 사용할 때 한 셀이 다른 셀을 어떻게 참조하는지에 따라 값이 결정되지 그 셀의 위치에 따라 값들이 결정되지 않는다. R 유저는 Shiny도 그러하다는 것을 잘 알 것이다. 이와 같이 논리적인 구조에 따라 코드가 실행되는 것을 **반응성(reactivity)**이라고 부르고 옵저버블 노트북은 이런 반응성 노트북의 한 형태이다. 요즈음 이런 반응성 노트북을 개발하려는 노력들이 상당히 진행되고 있다[@perkel2021reactive].

## 코드 실행을 조절하는 옵션 {#sec-code-exe}

문서에 포함된 코드들을 실행시키지 않을 수도 있고, 결과물에 코드가 아예 보이지 않게 할 수도 있다. 또 코드가 실행된 결과를 어떤 식으로 처리할지도 결정할 수 있다. 코드에 에러가 발생하거나 코드가 어떤 로그 메시지를 출력하는 것을 처리하는 방법도 결정할 수 있다. 

이 절의 설명은 콰르토 문서 ["Execution Options"](https://quarto.org/docs/computations/execution-options.html)에 자세히 나와 있으므로 참고한다.

### 옵션들의 위계: YAML에서 모든 코드 블록에 영향을 주는 내용을 정의

콰르토 소스 파일은 [@sec-yaml-header]에서 설명한 바와 같이 YAML 헤더로 시작된다. YAML 헤더에 들어가는 여러 가지 필드 가운데 코드 실행을 제어하는 가장 중요한 필드는 `execute`이다. 이 필드의 하위 필드로 코드 제어 옵션들을 지정하면 이 소스 파일에 포함된 모든 코드 블록은 여기서 지정한 옵션들에 의해서 영향을 받는다.

다음과 같이 설정했다고 치자.

``` .markdown
---
knitr: true
execute:
  echo: false
  message: false
  warning: false
  error: true
---
```

그러면 이 소스 파일 안의 모든 코드는 `echo: true`라는 옵션에 의해서 코드가 결과물에서 표시되지 않고, `message: false`와 `warning: false`에 의해서 코드가 출력하는 메시지와 경고가 보이지 않으며, `error: true`가 있어서 코드에 에러가 있어도 다음 과정을 진행시킨다. 그런데 코드 출력이 필요한 코드 블록이 있으면 코드 블록 옵션으로 `#| echo: true`로 바꾸어 사용한다.


### 코드 실행 여부 결정: `eval`

코드 실행 여부는 `eval`이라는 옵션을 사용한다. 만약 문서에 포함된 코드들을 실행시키지 않고 렌더링할 것이라면 YAML 헤더에 다음과 같이 지정할 수 있다.

``` .markdown
---
execute:
  eval: false
---
```

이렇게 YAML 헤더에 지정했다고 해도 아래와 같이 개별 코드 블록에서 `eval: true`라는 옵션을 사용하면, 해당 코드 블록은 실행가능하다. 콰르토 옵션 대부분 이런 식으로 코드에 가까운 옵션이 우선 순위를 가진다.

```{r}
#| echo: fenced
#| eval: true
hist(rnorm(1000))
```

### 소스 코드 관리 

콰르토는 소스 코드와 관련된 여러 가지 옵션들을 제공한다.

먼저 소스 코드 출력 여부는 `echo:` 라는 필드로 조절한다. `echo:`의 값은 `true` 또는 `false` 값으로 지정할 수 있다. 특별한 값으로 `echo: fenced`라는 값을 줄 수 있다. `true`는 코드를 출력하는 것이고 `false`는 코드를 출력하지 않는다. `fenced`는 추가 설명이 필요하다. 다음과 예를 보자.

````markdown
`r ''````{r}
#| echo: fenced
#| fig-cap: "간단한 히스토그램"
hist(rnorm(1000))
```
````

위와 같이 코드 블록은 아래와 같이 렌더링된다.. 

```{r}
#| echo: fenced
#| fig-cap: "간단한 히스토그램"
hist(rnorm(1000))
```

이 `echo: fenced` 옵션을 사용하면, 코드 블록 경계를 포함하여, 코드 불록 내부의 옵션과 소스 코드가 출력된다. 단, `echo: fenced` 옵션 부분은 제외하고 나머지 부분이 출력된다. 그런 다음 코드 실행 결과가 출력된다. 이와 같은 기능은 이 책과 같이 콰르토 매뉴얼에서 옵션 지정 방법을 설명할 때 편리하다.

#### 버바팀(Verbatim) 

입력한 것을 있는 그대로 출력하는 것을 버바팀이라고 한다. 컴퓨터 코드를 출력할 때 주로 사용된다.

- 인라인 버바팀은 문장 중간에 필요한 단어나 구를 백틱으로 둘러싸서 표현한다.

- 코드 블록 자체에 대한 버바팀 
  
    - R 마크다운 사용자들에게 코드 블록 버바팀 출력은 헷갈리는 주제였다[^computation-6]. 이것을 해결하기 위해 최신 니터 패키지(버전 1.37)[^computation-7]에서 `verbatim`이라는 엔진이 추가되었다. 이것은 특별한 종류의 코드 블록으로 이 안에서 코드는 블록은 실행되지 않고 코드 블록 경계를 포함하여 안의 코드가 있는 그대로 출력된다. 그림에서 백틱이 4개 사용됨을 주의한다. 이것은 안의 코드 블록이 3개의 백틱을 사용하고 있어서 이것과 구분할 수 있도록 하는 목적이 있다. `echo: fenced`를 사용하는 코드 블록과 다른 점은 `verbatim` 환경은 내부의 코드를 실행시키지 않는다는 점이다.
    
    ![verbatim 엔진 사용](images/verbatim.png){fig-align="left" width="400"}
    

[^computation-6]: <https://bookdown.org/yihui/rmarkdown-cookbook/verbatim-code-chunks.html>

[^computation-7]: <https://github.com/yihui/knitr/blob/master/NEWS.md#changes-in-knitr-version-137>



### 일반 텍스트 출력

코드 블록은 일반 텍스트를 출력할 수도 있는데, 먼저 이와 관련된 옵션들을 이해하기 위해서는 콰르토 문서 프로세싱 과정을 생각해 보아야 한다. 소스 코드가 출력한 일반 텍스트는 그 자체로 출력되게 사용할 수도 있을 것이다. 문서 프로세싱 과정에서 먼저 소스 코드를 실행하고, 그 결과를 해당 위치에 마크다운 포맷으로 가져다 놓고, 마지막에 팬독이 이 마크다운을 프로세싱하여 결과를 생성한다.

콰르토에서는 `output:`이라는 옵션으로 이 과정을 조절한다. 취할 수 있는 값은 `true`, `false`, `asis`이다. `true`는 출력하지 않는 것이고, `false`는 출력하는 것이다. 문제는 `asis`인데, 이것은 말그대로 있는 그대로 넘겨주라는 의미있다. 콰로트는 소스 코드가 출력한 텍스트를 주변에 마크다운 문법과 어울릴 수 있게 이것을 내부에서 마크다운으로 처리한다. 그 다음 팬독이 이 마크다운을 처리한다. `asis`는 첫 단계 마크다운 문법과 어울릴 수 있게 내부에서 마크다운으로 처리하는 과정을 생략하고 고스란히 팬독으로 넘겨주라는 의미이다.

예를 설명하기 위해서 R 언어의 `cat()` 함수를 사용해 보자. 둘 다 내용을 화면을 출력하지만, `cat()` 함수는 `print()` 함수와 다르게 값을 반환하지 않는다. `print()` 함수는 출력도 하지만 값을 반환한다.

```{r}
x <- print("Hello")
x
```

`cat()`는 그 내용을 출력한다.

```{r}
y <- cat("Hello")
y
```

이 `cat()` 함수를 사용하여 `output: asis` 옵션의 역할을 살펴보자. 다이내믹하게 프로그래밍 방식으로 콰르토 로고를 출력해 보자. R `glue` 패키지는 문자열 채움(string interpolation)을 지원하는 등의 기능을 제공하는 훌륭한 패키지이다.

다음은 아무런 옵션 없이 사용한 예이다. `cat()` 함수는 따옴표 안의 내용을 그대로 출력하고, 콰르토는 내부적으로 이것을 주면 마크다운과 어울리도록 처리해서(팬독에서 필요한 div로 변환), 결국은 아무런 효과 없이 그 내용이 최종 문서에 출력되게 한다.

```{r}
#| echo: fenced
library(glue)
logo <- "images/quarto.png"
cat(glue("![로고 출력]({logo})"))
```

여기에 `output: asis`를 주면, `cat()` 함수가 출력한 것이 "있는 그대로" 마크다운 파일에 놓인다. 팬독이 이를 처리하여 이미지를 불러온다.

```{r}
#| echo: fenced
#| output: asis
library(glue)
logo <- "images/quarto.png"
cat(glue("![로고 출력]({logo})"))
```


### 메시지, 경고문, 에러 출력

코드는 때로는 메시지나 경고문을 출력한다. 때로는 코드에 오류가 생겨서 에러가 발생하고 프로그램이 중단되고 에러 메시지를 출력한다. R 언어의 메시지, 경고문, 에러에 대해서는 해들리 위캄의 『Advance R』책에서 "Conditions" 장을 참고한다[^computation-8].

[^computation-8]: <https://adv-r.hadley.nz/conditions.html>

메시지나 경고문을 가리기 위해서는 `message: false`, `warning: false` 옵션을 사용한다. YAML 헤더에서는 `execute:` 필드의 서브 필드로 지정한다.

``` .markdown
---
execute:
  message: false
  warning: false
---
```

코드 불록에서는 그대로 사용한다. 다음은 아무런 옵션을 주지 않으면 메시지가 출력된다.

```{r}
#| echo: fenced
library(tidyverse)
```

패키지를 언로딩한다. 로딩된 패키지를 다시 로딩하는 경우 메시지가 원래 출력되지 않기 때문이다.

```{r}
#| echo: fenced
detach("package:tidyverse")
```

이번에는 `message: false` 옵션을 준 경우이다. 그러면 메시지가 출력되지 않는다.

```{r}
#| echo: fenced
#| message: false
library(tidyverse)
```

`error` 옵션은 이해를 필요로 한다. 콰르토가 소스 문서 코드를 실행하다가 에러가 발생하면 프로그램이 중단된다. 이런 디폴트는 코드 에러를 빨리 알아챌 수 있기 때문에 좋은 것이다. 그런데 에러 발생을 이미 알고 있고, 이 에러에 대한 설명을 하는 콰르토 문서를 작성하는 경우 문제가 된다. 이 경우 `error: true` 옵션을 사용한다. R에서 `stop()` 함수는 일부러 에러를 만드는 함수이다.

다음 코드 블록은 에러가 발생하지만 문서가 프로세싱되고 그 에러 메시지가 문서에 출력된다.

```{r}
#| echo: fenced
#| error: true
stop("에러가 발생함")
```

## 코드가 생성하는 플롯을 조절하는 옵션 {#sec-code-plot-control}

소스 코드는 플롯을 출력할 수 있고, 이 플롯의 다양한 측면을 조절할 수 있는 옵션들이 준비되어 있다.

먼저 비단 플롯에만 적용되는 것은 아니지만 모든 코드 블록은 `label`이라는 옵션으로 시작하는 것이 좋다. `label` 옵션은 코드 블록에 레이블을 붙이는 것으로, 이 레이블이 있으면 코드가 생성하는 플롯에 대한 상호 참조를 만들 때 편리하다. 

::: {.callout-tip}
## 콰르토에서 상호 참조를 위한 접두사 

참고로 콰르토에서 레이블을 만들 때 적용되는 규칙이 있는데, 다음과 같은 접두사로 시작한다. 콰르토트 `그림 1.2를 보면...`과 같은 상호 참조를 만들기 위해서 그림은 그림대로, 표는 표대로, 장절은 장절대로 그 순서를 파악하여 번호를 지정하고, 또는 그 리스트를 만들 때 이렇게 모아진 것을 활용하게 된다. 따라서 이 접두사를 잘 연습할 필요가 있다. 그림이나 표를 출력하는 코드 블록에 레이블을 쓸 때는 앞의 `#`은 빼고 쓴다.

- 그림: `#fig-`로 시작
- 표: `#tbl-`로 시작 
- 장절: `#sec-`으로 시작 
- 코드 리스트: `#lst-`로 시작 
- 수식: `#thm-`(theorum), `#lem-`(lemma) 등 
:::



```{r}
#| echo: fenced
#| label: fig-my-plot
#| fig-cap: "펭귄 지느러미발과 체중"
#| warning: false
library(ggplot2)
library(palmerpenguins)
ggplot(penguins, aes(flipper_length_mm, body_mass_g)) + 
  geom_point(aes(color = species)) +
  theme_bw()
```

이 플롯에 대한 상호 참조를 만들 때는 `[@fig-my-plot]`와 같이 `[]`안에 `@` 기호를 쓴 다음 레이블을 붙여 쓴다.

```{verbatim}
[@fig-my-plot]을 보면 ...
```

이것은 다음과 같이 렌더링 된다.

[@fig-my-plot]을 보면 ...

앞에서 `fig-cap:`은 플롯에 대한 캡션을 지정하는 옵션이다. `label` 옵션과 `fig-cap` 옵션은 항상 같이 사용할 것을 권한다. `label` 없이 `fig-cap` 만 지정한 경우는 캡션이 만들어지지 않고, `fig-cap` 없이 `label`만 있는 경우에는 캡션에 물음표 등이 찍힌다. 위에서 설명했지만 그림에 대한 레이블은 `#fig-`(코드 블록에서는 `fig-`로 시작)로 시작한다. 따라서 항상 다음과 같이 되어 있게 하는 습관을 들인다.

``` markdown
#| label: fig-my-plot
#| fig-cap: "펭귄 지느러미발과 체중"
```

코드가 출력하는 플롯이 여러 개 있을 때 그림 레이아웃을 정할 때와 같은 옵션을 지정할 수도 있다. 다음 코드 블록은 2개의 플롯을 출력한다. 이것을 배치하기 위하여 `layout-ncol: 2`로 2개의 열을 지정했다. 그리고 `fig-cap`으로 전체의 캡션을 `fig-subcap`으로 각각의 플롯에 대한 캡션을 지정했다. 내부 플롯의 개수에 맞추어 YAML 리스트로 캡션을 지정한다.

```{r}
#| echo: fenced
#| label: fig-mtcars
#| layout-ncol: 2
#| fig-cap: 무게, 실린더 개수와 연비와의 관계
#| warning: false
#| fig-subcap:
#|   - "자동차 무게와 연비"
#|   - "실린더 개수와 연비"
p1 <- ggplot(mtcars, aes(wt, mpg)) + 
        geom_point()
p1

p2 <- ggplot(mtcars, aes(factor(cyl), mpg)) +
        geom_boxplot()
p2
```

디폴트로 캡션은 플롯 아래에 놓인다. 이 위치를 바꿀 수도 있다. YAML 헤더에서 `fig-cap-location:` 필드에서 `bottom`, `top`, `margin` 가운데 하나를 지정하면 된다.

플롯의 크기는 `fig-width:`, `fig-height:` 필드에 인치 단위로 값을 지정한다. 콰르토는 문서 포맷마다 플롯의 디폴트 크기를 정해 두고 있다[^computation-9]. 디폴트 HTML 경우은 7X5 이다. `fig-align:`은 플롯을 왼쪽(`left`), 오른쪽(`right`), 중앙(`center`)으로 정렬한다.

[^computation-9]: <https://quarto.org/docs/computations/execution-options.html#figure-options>

```{r}
#| echo: fenced
#| warning: false
#| label: fig-my-boxplot
#| fig-cap: "펭귄 종과 체중"
#| fig-width: 5
#| fig-height: 4
#| fig-align: "left"
ggplot(penguins, aes(species, body_mass_g)) + 
  geom_boxplot(aes(fill=species)) + 
  theme_bw() +
  theme(legend.position="none")
```

하나의 소스 문서를 가지고 다양한 포맷의 문서를 만들 때, 플롯의 크기는 보통 문서 포맷(format)별로 정해서 작업하는 것이 좋다. 그렇게 하기 위해서는 YAML 헤더의 `format:` 필드에서 각 포맷별로 플롯의 크기를 지장하고 사용하는 것이 좋다.

## 인라인 코드

인라인(inline) 코드는 텍스트 중간에 값을 넣을 때 사용하는 코드를 말한다. 이를테면 "전체 연구 대상은 X 명이다."라고 했을 때 이 X는 데이터가 수집되면서 점점 더 증가하는데, 이것을 다이내믹하게 코드를 통해서 계산하여 텍스트에 포함되게 만드는 것이다.

R 마크다운/니터는 비교적 간단하다. `` `r knitr::inline_expr("1+1")` ``과 같이, 백틱으로 둘러싸고 처음 백틱 다음에 바로 붙여서 `r`를 쓴 다음, R 표현식을 넣는다. 그러면 R 표현식의 값이 출력된다.

팔머 펭귄 데이터셋을 사용한다.

```{r}
library(palmerpenguins)
```

다음과 같은 문장을 본문에서 작성한다.

```{verbatim}
데이터셋에는 `r nrow(penguins)`개 행과 `r ncol(penguins)`개의 열이 있다.
```

이 문장은 다음과 같이 렌더링된다.

-------
데이터셋에는 `r nrow(penguins)`개 행과 `r ncol(penguins)`개의 열이 있다.
-------

주피터 노트북에서 인라인 코드를 넣으려면 `IPython.display` 모듈을 사용한다. 다음 설명은 콰르토 공식 사이트에서 인용한 것이다. 여기서는 `Markdown` 클래스에 중점을 두고 있는데, 전반적인 `IPython.display` 모듈에 관해서는 [@sec-rich-ipython]을 읽기 바란다.

내용은 코드 셀(Code Cell)에 입력한다. 이것은 파이썬 코드이고, 이 파이썬 코드는 마크다운 텍스트를 만들고 이것을 출력한다. 텍스트를 마크다운으로 변환하는 역할은 `IPython.display.Markdown` 함수가 하고, 이것을 출력하는 것은 `IPython.display.display` 함수가 담당한다. 그리고 텍스트는 파이썬 3중 인용 기호(triple quote)를 사용하여 복수의 행으로 입력하였다. 이 텍스트 안에 값을 채우기 위해서(interpolate) `str.format()` 함수를 사용하였다. 이 경우에는 파이썬 세션에 있는 `radius = 10` 값을 텍스트 안에 채운다.

```{.python}
radius = 10

from IPython.display import display, Markdown

display(Markdown("""
## Circle

The radius of the circle is {radius}.
""".format(radius = radius)))
```

다음은 실제로 실행한 예이다.

![주피터랩에서 실행](images/jupyter_display.png){#fig-jupyter-display-md}

## 참고문헌
